<h1>Алгоритм Евкліда знаходження НСД (найбільшого спільного дільника)</h1>

<p>
    Дано два цілих невід'ємних числа $a$ і $b$. Потрібно знайти їх найбільший спільний дільник, тобто найбільше таке число, яке є дільником одночасно і $a$,
    і $b$. На англійській мові "найбільший спільний дільник" пишеться "greatest common divisor", і позначається як ${\rm gcd}$:
</p>
$$ {\rm gcd}(a,b) = \max_{k=1 \ldots \infty \ :\  k|a \ \&\  k|b} k $$
<p>(тут символом "$|$" позначено ділимість, тобто "$k|a$" означає "$k$ націло ділить $a$")</p>

<p>
    Коли одне з чисел рівне нулю, а інше відмінне від нуля, тоді їх найбільшим спільним дільником, згідно визначенню, буде друге число. Коли обидва числа рівні
    нулю, результат не визначений (підійде будь-яке нескінченно велике число), тому покладемо у цьому випадку найбільший спільний дільник рівним нулю. Тому
    можна говорити про таке правило: якщо одне з чисел рівне нулю, то їх найбільший спільним дільник рівний другому числу.
</p>

<p><b>Алгоритм Евкліда</b>, що розглядається нижче, вирішує задачу знаходження найбільшого спільного дільника двох чисел $a$ і $b$ за $O(\log \min(a,b))$.</p>

<p>Даний алгоритм був вперше описаний у книзі Евкліда "Начала" (близько 300 р. до н.е).</p>



<h2>Алгоритм</h2>

<p>Сам алгоритм надзвичайно простий і описується наступною формулою:</p>

$$ {\rm gcd}(a,b) = \cases{ a, & якщо b=0 \cr {\rm gcd} (b, a\ {\rm mod}\ b), & інакше } $$



<h2>Реалізація</h2>

{{ format_code('gcd_recursive.cpp') }}

<p>Використовуючи тернарний умовний оператор C++, алгоритм можна записати ще коротше:</p>

{{ format_code('gcd_ternary.cpp') }}

<p>Нарешті, наведемо і нерекурсивну форму алгоритму:</p>

{{ format_code('gcd.cpp') }}



<h2>Доведення коректності</h2>

<p>
    Спочатку зауважимо, що при кожній ітерації алгоритму Евкліда його другий аргумент завжди зменшується, а отже, оскільки він невід'ємний, алгоритм Евкліда
    <b>завжди завершується</b>.
</p>

<p>Для <b>доведення коректності</b> нам необхідно показати, що ${\rm gcd}(a,b) = {\rm gcd} (b, a\ {\rm mod}\ b)$ для будь-яких $a \ge 0, b > 0$.</p>

<p>
    Покажемо, що величина, що стоїть в лівій частини рівності, ділиться на величину у правій, а та, шо стоїть у правій - ділиться на величину у лівій. Очевидно,
    це буде означати, що ліва і права частини збігаються, що і доведе коректність алгоритму Евкліда.
</p>

<p>Позначимо $d = {\rm gcd}(a,b)$. Значить, за визначенням, $d|a$ і $d|b$.</p>

<p>Далі, розкладемо залишок від ділення $a$ на $b$ через їх частку:</p>
$$ a\ {\rm mod}\ b = a - b \left\lfloor \frac{a}{b} \right\rfloor $$

<p>Звідси випливає:</p>
$$ d\ |\ (a\ {\rm mod}\ b) $$

<p>Отже, згадуючи твердження $d|b$, отримуємо систему:</p>
$$ \cases{ d\ |\ b, \cr d\ |\ (a\ {\rm mod}\ b) } $$

<p>
    Скористаємося тепер наступним простим фактом: якщо для якихось трьох чисел $p,q,r$ виконуються: $p|q$ і $p|r$, то виконується і: $p\ |\ {\rm gcd}(q,r)$.
    У нашій ситуації отримуємо:
</p>
$$ d\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) $$
<p>Або, підставляючи замість $d$ його визначення як ${\rm gcd}(a,b)$, отримуємо:</p>
$$ {\rm gcd}(a,b)\ |\ {\rm gcd}(b, a\ {\rm mod}\ b) $$

<p>Отже, ми здійснили половину доведення: показали, що ліва частина ділить праву. Друга половина доведення аналогічна.</p>



<h2>Час роботи</h2>

<p>Час роботи алгоритму оцінюється <b>теоремою Ламе</b>, яка встановлює дивовижний зв'язок алгоритму Евкліда і послідовності Фібоначчі:</p>

<p>Якщо $a > b \ge 1$ і $b < F_n$ для деякого $n$, то алгоритм Евкліда виконає не більше $n-2$ рекурсивних викликів.</p>

<p>
    Більше того, можна показати, що верхня межа цієї теореми - оптимальна. При $a = F_n, b = F_{n-1}$ буде виконано саме $n-2$ рекурсивних викликів. Іншими
    словами, <b>послідовні числа Фібоначчі - найгірші вхідні дані</b> для алгоритму Евкліда.
</p>

<p>
    Враховуючи, що числа Фібоначчі ростуть експоненціально (як константа в степені $n$), отримуємо, що алгоритм Евкліда виконується за $O(\log \min(a,b))$
    операцій множення.
</p>



<h2>НСК (найменше спільне кратне)</h2>

<p>Обчислення найменшого спільного кратного (least common multiplier, lcm) зводиться до обчислення $\rm gcd$ наступним простим твердженням:</p>

$$ {\rm lcm}(a,b) = \frac{ a \cdot b }{ {\rm gcd}(a,b) } $$

<p>Таким чином, обчислення НСК також можна здійснити за допомогою алгоритму Евкліда, з тією ж асимптотикою:</p>

{{ format_code('lcm.cpp') }}

<p>(тут вигідно спочатку поділити на $\rm gcd$, а тільки потім помножити на $b$, оскільки це допоможе уникнути переповнення у деяких випадках)</p>
    


<h2>Література</h2>

<ul>
    <li>
        <a href="https://www.google.com/search?q=Thomas%20H.%20Cormen%20-%20Introduction%20to%20Algorithms">
            Thomas H. Cormen - <b>Introduction to Algorithms</b>
        </a>
    </li>
</ul>